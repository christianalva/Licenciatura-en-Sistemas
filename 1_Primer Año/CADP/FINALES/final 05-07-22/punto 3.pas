//dada la siguiente declaracion de tipos de datos y variables, justificar para cada sentencia numeradas son validas o invalidas

program ej3;
type
  cadena100=string[100];
  
  cliente = record 
    codigo:integer;
    tel:integer;
    dir:cadena100;
  end;
  
  clientes = ^nodo;
  
  nodo = record 
    datos:cliente;
    sig:clientes;
  end;
  
var 
  c:cliente;
  cli:clientes;
begin 

  1.read(c);//INVALIDO, NO SE PUEDE LEER DESDE TECLADO DIRECTAMENTE UN REGISTRO
  
  2.new(c);// INVALIDO, NEW SE USA PARA RESERVAR MEMORIA DINAMICA PARA LA VARIABLE A LA QUE APUNTA UN PUNTERO. C ES UNA VARIABLE DE TIPO REGISTRO, NO UN PUNTERO
  
  3.read(cli);//INVALIDO, CLIENTES ES UN PUNTERO A NODO Y GUARDA UNA DIRECCION DE MEMORIA, NO ES POSIBLE ASIGNARLEUNA DIRECCION DE MEMEORIA POR LECTURA COMO SE PRETENDE HACER CON READ
  
  4.c:=nil;//INVALIDO, NIL ES UNA PALABRA RESERVADA QUE REPRESENTA UN VALOR ESPECIAL QUE PUEDE TOMAR UN PUNTERO QUE NO APUNTA A NINGUN LUGAR EN PARTICULAR, C ES UNA VARIABLE DE TIPO REGISTRO
  
  5.cli:=nil;//VALIDO, CLI ES UNA VARIABLE DE TIPO PUNTERO CLI:=NIL LE ASIGNA UN VALOR ESPECIA QUE INDICA QUE EL PUNTERO NO APUNTA A NINGUNA DIRECCION EN PARTICULAR
  
  6.dispose(cli);// VALIDO, DISPOSE LIBERA LA MEMORIA DINAMICA ALOCADA A UN PUNTERO, CLI ES DE TIPO PUNTERO. SIN EMBARGO BALE RECALCAR QUE EN ESTE CASO NUNCA SE LE ASIGNO MEMORIA DINAMICAA CLI MEDIANTE NEW
  
  7.read(cli^.codigo);//INVALIDO, SE ESTA QUERIENDO ACCEDER A LA VARIABLE CODIGO DEL DATO DEL NODO AL QUE APUNTA CLI, PERO NO SE ESTA HACIENDO CORRECTAMENTE. TAMBIEN HAY QUE ACCEDER A DATO, NO SE PUEDE ACCEDER A CODIGO DIRECTAMENTE. LA LINEA CORRECTA SERIA : CLI^.DATO.CODIGO
  
  8.write(c.codigo);//VALIDO, SE ESTA ACEEDIENDO CORRECTAMENTE A LA VARIABLE CODIGO DEL REGISTRO C. SI ESTA TIENE VALOR SE IMPRIMIRA EN PANTALLA


end.





